// Generated by pyang using OpenConfig https://github.com/openconfig/public.
//
// Copyright 2017 OpenConfigd Project.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

// "fmt"

//struct for container static:interface
type Interfacex struct {
	// original -> static:ifname
	Ifname string `mapstructure:"ifname" json:"ifname,omitempty"`
}

func (lhs *Interfacex) Equal(rhs *Interfacex) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Ifname != rhs.Ifname {
		return false
	}
	return true
}

//struct for container static:nexthop
type Nexthop struct {
	// original -> static:address
	//static:address's original type is inet:ipv4-address
	Address string `mapstructure:"address" json:"address,omitempty"`
}

func (lhs *Nexthop) Equal(rhs *Nexthop) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Address != rhs.Address {
		return false
	}
	return true
}

//struct for container static:route
type Route struct {
	// original -> static:prefix
	//static:prefix's original type is inet:ipv4-prefix
	Prefix string `mapstructure:"prefix" json:"prefix,omitempty"`
	// original -> static:nexthop
	NexthopList []Nexthop `mapstructure:"nexthop" json:"nexthop,omitempty"`
	// original -> static:interface
	InterfaceList []Interfacex `mapstructure:"interface" json:"interface,omitempty"`
	// original -> static:distance
	Distance uint8 `mapstructure:"distance" json:"distance,omitempty"`
}

func (lhs *Route) Equal(rhs *Route) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Prefix != rhs.Prefix {
		return false
	}
	if len(lhs.NexthopList) != len(rhs.NexthopList) {
		return false
	}
	{
		lmap := make(map[string]*Nexthop)
		for i, l := range lhs.NexthopList {
			lmap[mapkey(i, string(l.Address))] = &lhs.NexthopList[i]
		}
		for i, r := range rhs.NexthopList {
			if l, y := lmap[mapkey(i, string(r.Address))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if len(lhs.InterfaceList) != len(rhs.InterfaceList) {
		return false
	}
	{
		lmap := make(map[string]*Interfacex)
		for i, l := range lhs.InterfaceList {
			lmap[mapkey(i, string(l.Ifname))] = &lhs.InterfaceList[i]
		}
		for i, r := range rhs.InterfaceList {
			if l, y := lmap[mapkey(i, string(r.Ifname))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if lhs.Distance != rhs.Distance {
		return false
	}
	return true
}
