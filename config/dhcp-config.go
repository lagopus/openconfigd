// Generated by pyang using OpenConfig https://github.com/openconfig/public.
//
// Copyright 2017 OpenConfigd Project.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
	"fmt"
)

func mapkey(index int, name string) string {
	if name != "" {
		return name
	}
	return fmt.Sprintf("%v", index)
}

//struct for container dhcp:server-address
type ServerAddress struct {
	// original -> dhcp:address
	//dhcp:address's original type is inet:ipv4-address
	Address string `mapstructure:"address" json:"address,omitempty"`
}

func (lhs *ServerAddress) Equal(rhs *ServerAddress) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Address != rhs.Address {
		return false
	}
	return true
}

//struct for container dhcp:server-group
type ServerGroup struct {
	// original -> dhcp:server-group-name
	ServerGroupName string `mapstructure:"server-group-name" json:"server-group-name,omitempty"`
	// original -> dhcp:server-address
	ServerAddressList []ServerAddress `mapstructure:"server-address" json:"server-address,omitempty"`
}

func (lhs *ServerGroup) Equal(rhs *ServerGroup) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.ServerGroupName != rhs.ServerGroupName {
		return false
	}
	if len(lhs.ServerAddressList) != len(rhs.ServerAddressList) {
		return false
	}
	{
		lmap := make(map[string]*ServerAddress)
		for i, l := range lhs.ServerAddressList {
			lmap[mapkey(i, string(l.Address))] = &lhs.ServerAddressList[i]
		}
		for i, r := range rhs.ServerAddressList {
			if l, y := lmap[mapkey(i, string(r.Address))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	return true
}

//struct for container dhcp:range
type Range struct {
	// original -> dhcp:range-index
	RangeIndex uint16 `mapstructure:"range-index" json:"range-index,omitempty"`
	// original -> dhcp:range-start-ip
	//dhcp:range-start-ip's original type is inet:ipv4-address
	RangeStartIp string `mapstructure:"range-start-ip" json:"range-start-ip,omitempty"`
	// original -> dhcp:range-end-ip
	//dhcp:range-end-ip's original type is inet:ipv4-address
	RangeEndIp string `mapstructure:"range-end-ip" json:"range-end-ip,omitempty"`
}

func (lhs *Range) Equal(rhs *Range) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.RangeIndex != rhs.RangeIndex {
		return false
	}
	if lhs.RangeStartIp != rhs.RangeStartIp {
		return false
	}
	if lhs.RangeEndIp != rhs.RangeEndIp {
		return false
	}
	return true
}

//struct for container dhcp:host
type Host struct {
	// original -> dhcp:host-name
	HostName string `mapstructure:"host-name" json:"host-name,omitempty"`
	// original -> dhcp:mac-address
	MacAddress string `mapstructure:"mac-address" json:"mac-address,omitempty"`
	// original -> dhcp:ip-address
	//dhcp:ip-address's original type is inet:ipv4-address
	IpAddress string `mapstructure:"ip-address" json:"ip-address,omitempty"`
}

func (lhs *Host) Equal(rhs *Host) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.HostName != rhs.HostName {
		return false
	}
	if lhs.MacAddress != rhs.MacAddress {
		return false
	}
	if lhs.IpAddress != rhs.IpAddress {
		return false
	}
	return true
}

//struct for container dhcp:dhcp-ip-pool
type DhcpIpPool struct {
	// original -> dhcp:ip-pool-name
	IpPoolName string `mapstructure:"ip-pool-name" json:"ip-pool-name,omitempty"`
	// original -> dhcp:interface
	Interface string `mapstructure:"interface" json:"interface,omitempty"`
	// original -> dhcp:subnet
	//dhcp:subnet's original type is inet:ipv4-prefix
	Subnet string `mapstructure:"subnet" json:"subnet,omitempty"`
	// original -> dhcp:gateway-ip
	//dhcp:gateway-ip's original type is inet:ipv4-address
	GatewayIp string `mapstructure:"gateway-ip" json:"gateway-ip,omitempty"`
	// original -> dhcp:default-lease-time
	DefaultLeaseTime uint32 `mapstructure:"default-lease-time" json:"default-lease-time,omitempty"`
	// original -> dhcp:max-lease-time
	MaxLeaseTime uint32 `mapstructure:"max-lease-time" json:"max-lease-time,omitempty"`
	// original -> dhcp:host
	HostList []Host `mapstructure:"host" json:"host,omitempty"`
	// original -> dhcp:range
	RangeList []Range `mapstructure:"range" json:"range,omitempty"`
	// original -> dhcp:option
	Option Option `mapstructure:"option" json:"option,omitempty"`
	// original -> dhcp:failover-role
	FailoverRole string `mapstructure:"failover-role" json:"failover-role,omitempty"`
	// original -> dhcp:failover-peer-address
	//dhcp:failover-peer-address's original type is inet:ipv4-address
	FailoverPeerAddress string `mapstructure:"failover-peer-address" json:"failover-peer-address,omitempty"`
}

func (lhs *DhcpIpPool) Equal(rhs *DhcpIpPool) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.IpPoolName != rhs.IpPoolName {
		return false
	}
	if lhs.Interface != rhs.Interface {
		return false
	}
	if lhs.Subnet != rhs.Subnet {
		return false
	}
	if lhs.GatewayIp != rhs.GatewayIp {
		return false
	}
	if lhs.DefaultLeaseTime != rhs.DefaultLeaseTime {
		return false
	}
	if lhs.MaxLeaseTime != rhs.MaxLeaseTime {
		return false
	}
	if len(lhs.HostList) != len(rhs.HostList) {
		return false
	}
	{
		lmap := make(map[string]*Host)
		for i, l := range lhs.HostList {
			lmap[mapkey(i, string(l.HostName))] = &lhs.HostList[i]
		}
		for i, r := range rhs.HostList {
			if l, y := lmap[mapkey(i, string(r.HostName))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if len(lhs.RangeList) != len(rhs.RangeList) {
		return false
	}
	{
		lmap := make(map[string]*Range)
		for i, l := range lhs.RangeList {
			lmap[mapkey(i, string(l.RangeIndex))] = &lhs.RangeList[i]
		}
		for i, r := range rhs.RangeList {
			if l, y := lmap[mapkey(i, string(r.RangeIndex))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if !lhs.Option.Equal(&(rhs.Option)) {
		return false
	}
	if lhs.FailoverRole != rhs.FailoverRole {
		return false
	}
	if lhs.FailoverPeerAddress != rhs.FailoverPeerAddress {
		return false
	}
	return true
}

//struct for container dhcp:classless-routes
type ClasslessRoutes struct {
	// original -> dhcp:prefix
	//dhcp:prefix's original type is inet:ipv4-prefix
	Prefix string `mapstructure:"prefix" json:"prefix,omitempty"`
	// original -> dhcp:nexthop
	//dhcp:nexthop's original type is inet:ipv4-address
	Nexthop string `mapstructure:"nexthop" json:"nexthop,omitempty"`
}

func (lhs *ClasslessRoutes) Equal(rhs *ClasslessRoutes) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Prefix != rhs.Prefix {
		return false
	}
	if lhs.Nexthop != rhs.Nexthop {
		return false
	}
	return true
}

//struct for container dhcp:sip-servers
type SipServers struct {
	// original -> dhcp:server
	//dhcp:server's original type is inet:ipv4-address
	Server string `mapstructure:"server" json:"server,omitempty"`
}

func (lhs *SipServers) Equal(rhs *SipServers) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Server != rhs.Server {
		return false
	}
	return true
}

//struct for container dhcp:voip-tftp-servers
type VoipTftpServers struct {
	// original -> dhcp:server
	//dhcp:server's original type is inet:ipv4-address
	Server string `mapstructure:"server" json:"server,omitempty"`
}

func (lhs *VoipTftpServers) Equal(rhs *VoipTftpServers) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Server != rhs.Server {
		return false
	}
	return true
}

//struct for container dhcp:ntp-servers
type NtpServers struct {
	// original -> dhcp:server
	//dhcp:server's original type is inet:ipv4-address
	Server string `mapstructure:"server" json:"server,omitempty"`
}

func (lhs *NtpServers) Equal(rhs *NtpServers) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Server != rhs.Server {
		return false
	}
	return true
}

//struct for container dhcp:domain-name-servers
type DomainNameServers struct {
	// original -> dhcp:server
	//dhcp:server's original type is inet:ipv4-address
	Server string `mapstructure:"server" json:"server,omitempty"`
}

func (lhs *DomainNameServers) Equal(rhs *DomainNameServers) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.Server != rhs.Server {
		return false
	}
	return true
}

//struct for container dhcp:option
type Option struct {
	// original -> dhcp:dhcp-server-identifier
	//dhcp:dhcp-server-identifier's original type is inet:ipv4-address
	DhcpServerIdentifier string `mapstructure:"dhcp-server-identifier" json:"dhcp-server-identifier,omitempty"`
	// original -> dhcp:domain-name
	DomainName string `mapstructure:"domain-name" json:"domain-name,omitempty"`
	// original -> dhcp:domain-name-servers
	DomainNameServersList []DomainNameServers `mapstructure:"domain-name-servers" json:"domain-name-servers,omitempty"`
	// original -> dhcp:ntp-servers
	NtpServersList []NtpServers `mapstructure:"ntp-servers" json:"ntp-servers,omitempty"`
	// original -> dhcp:interface-mtu
	InterfaceMtu uint32 `mapstructure:"interface-mtu" json:"interface-mtu,omitempty"`
	// original -> dhcp:netbios-name-server
	//dhcp:netbios-name-server's original type is inet:ip-address
	NetbiosNameServer string `mapstructure:"netbios-name-server" json:"netbios-name-server,omitempty"`
	// original -> dhcp:netbios-node-type
	NetbiosNodeType uint32 `mapstructure:"netbios-node-type" json:"netbios-node-type,omitempty"`
	// original -> dhcp:netbios-scope
	NetbiosScope string `mapstructure:"netbios-scope" json:"netbios-scope,omitempty"`
	// original -> dhcp:tftp-server-name
	TftpServerName string `mapstructure:"tftp-server-name" json:"tftp-server-name,omitempty"`
	// original -> dhcp:bootfile-name
	BootfileName string `mapstructure:"bootfile-name" json:"bootfile-name,omitempty"`
	// original -> dhcp:voip-tftp-servers
	VoipTftpServersList []VoipTftpServers `mapstructure:"voip-tftp-servers" json:"voip-tftp-servers,omitempty"`
	// original -> dhcp:sip-servers
	SipServersList []SipServers `mapstructure:"sip-servers" json:"sip-servers,omitempty"`
	// original -> dhcp:classless-routes
	ClasslessRoutesList []ClasslessRoutes `mapstructure:"classless-routes" json:"classless-routes,omitempty"`
	// original -> dhcp:time-offset
	TimeOffset int32 `mapstructure:"time-offset" json:"time-offset,omitempty"`
}

func (lhs *Option) Equal(rhs *Option) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.DhcpServerIdentifier != rhs.DhcpServerIdentifier {
		return false
	}
	if lhs.DomainName != rhs.DomainName {
		return false
	}
	if len(lhs.DomainNameServersList) != len(rhs.DomainNameServersList) {
		return false
	}
	{
		lmap := make(map[string]*DomainNameServers)
		for i, l := range lhs.DomainNameServersList {
			lmap[mapkey(i, string(l.Server))] = &lhs.DomainNameServersList[i]
		}
		for i, r := range rhs.DomainNameServersList {
			if l, y := lmap[mapkey(i, string(r.Server))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if len(lhs.NtpServersList) != len(rhs.NtpServersList) {
		return false
	}
	{
		lmap := make(map[string]*NtpServers)
		for i, l := range lhs.NtpServersList {
			lmap[mapkey(i, string(l.Server))] = &lhs.NtpServersList[i]
		}
		for i, r := range rhs.NtpServersList {
			if l, y := lmap[mapkey(i, string(r.Server))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if lhs.InterfaceMtu != rhs.InterfaceMtu {
		return false
	}
	if lhs.NetbiosNameServer != rhs.NetbiosNameServer {
		return false
	}
	if lhs.NetbiosNodeType != rhs.NetbiosNodeType {
		return false
	}
	if lhs.NetbiosScope != rhs.NetbiosScope {
		return false
	}
	if lhs.TftpServerName != rhs.TftpServerName {
		return false
	}
	if lhs.BootfileName != rhs.BootfileName {
		return false
	}
	if len(lhs.VoipTftpServersList) != len(rhs.VoipTftpServersList) {
		return false
	}
	{
		lmap := make(map[string]*VoipTftpServers)
		for i, l := range lhs.VoipTftpServersList {
			lmap[mapkey(i, string(l.Server))] = &lhs.VoipTftpServersList[i]
		}
		for i, r := range rhs.VoipTftpServersList {
			if l, y := lmap[mapkey(i, string(r.Server))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if len(lhs.SipServersList) != len(rhs.SipServersList) {
		return false
	}
	{
		lmap := make(map[string]*SipServers)
		for i, l := range lhs.SipServersList {
			lmap[mapkey(i, string(l.Server))] = &lhs.SipServersList[i]
		}
		for i, r := range rhs.SipServersList {
			if l, y := lmap[mapkey(i, string(r.Server))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if len(lhs.ClasslessRoutesList) != len(rhs.ClasslessRoutesList) {
		return false
	}
	{
		lmap := make(map[string]*ClasslessRoutes)
		for i, l := range lhs.ClasslessRoutesList {
			lmap[mapkey(i, string(l.Prefix))] = &lhs.ClasslessRoutesList[i]
		}
		for i, r := range rhs.ClasslessRoutesList {
			if l, y := lmap[mapkey(i, string(r.Prefix))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	if lhs.TimeOffset != rhs.TimeOffset {
		return false
	}
	return true
}

//struct for container dhcp:server
type Server struct {
	// original -> dhcp:default-lease-time
	DefaultLeaseTime uint32 `mapstructure:"default-lease-time" json:"default-lease-time,omitempty"`
	// original -> dhcp:max-lease-time
	MaxLeaseTime uint32 `mapstructure:"max-lease-time" json:"max-lease-time,omitempty"`
	// original -> dhcp:ping-check
	//dhcp:ping-check's original type is boolean
	PingCheck bool `mapstructure:"ping-check" json:"ping-check,omitempty"`
	// original -> dhcp:option
	Option Option `mapstructure:"option" json:"option,omitempty"`
	// original -> dhcp:dhcp-ip-pool
	DhcpIpPoolList []DhcpIpPool `mapstructure:"dhcp-ip-pool" json:"dhcp-ip-pool,omitempty"`
}

func (lhs *Server) Equal(rhs *Server) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if lhs.DefaultLeaseTime != rhs.DefaultLeaseTime {
		return false
	}
	if lhs.MaxLeaseTime != rhs.MaxLeaseTime {
		return false
	}
	if lhs.PingCheck != rhs.PingCheck {
		return false
	}
	if !lhs.Option.Equal(&(rhs.Option)) {
		return false
	}
	if len(lhs.DhcpIpPoolList) != len(rhs.DhcpIpPoolList) {
		return false
	}
	{
		lmap := make(map[string]*DhcpIpPool)
		for i, l := range lhs.DhcpIpPoolList {
			lmap[mapkey(i, string(l.IpPoolName))] = &lhs.DhcpIpPoolList[i]
		}
		for i, r := range rhs.DhcpIpPoolList {
			if l, y := lmap[mapkey(i, string(r.IpPoolName))]; !y {
				return false
			} else if !r.Equal(l) {
				return false
			}
		}
	}
	return true
}

type ServerGroupList struct {
	ServerGroupList []ServerGroup `mapstructure:"server-group" json:"server-group,omitempty"`
}

//struct for container dhcp:dhcp
type Dhcp struct {
	// original -> dhcp:server
	Server Server `mapstructure:"server" json:"server,omitempty"`
	// original -> dhcp:relay
	Relay ServerGroupList `mapstructure:"relay" json:"relay,omitempty"`
}

func (lhs *Dhcp) Equal(rhs *Dhcp) bool {
	if lhs == nil || rhs == nil {
		return false
	}
	if !lhs.Server.Equal(&(rhs.Server)) {
		return false
	}
	// if len(lhs.Relay) != len(rhs.Relay) {
	// 	return false
	// }
	// {
	// 	lmap := make(map[string]*ServerGroup)
	// 	for i, l := range lhs.Relay {
	// 		lmap[mapkey(i, string(l.ServerGroupName))] = &lhs.Relay[i]
	// 	}
	// 	for i, r := range rhs.Relay {
	// 		if l, y := lmap[mapkey(i, string(r.ServerGroupName))]; !y {
	// 			return false
	// 		} else if !r.Equal(l) {
	// 			return false
	// 		}
	// 	}
	// }
	return true
}
