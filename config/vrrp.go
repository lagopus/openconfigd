// Copyright 2017 OpenConfigd Project.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	//"strings"
	"sync"
	"text/template"
	"time"

	"github.com/mitchellh/mapstructure"
	"golang.org/x/net/context"
)

type VrrpConfig []Vrrp

type VrrpInstance struct {
	//VrfId    int
	VrId     uint8
	ExitFunc func()
}

var VrrpInstanceMap = map[string][]*VrrpInstance{}

func VrrpServerStart(config string, pid string, vrf string) func() {
	binary, err := exec.LookPath("keepalived")
	if err != nil {
		return nil
	}

	ctx, cancel := context.WithCancel(context.Background())
	done := make(chan struct{})
	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		defer wg.Done()
		for {
			time.Sleep(time.Second * 10)

			cmd := exec.CommandContext(ctx, binary,
				"--vrrp",
				// "-l",
				"-D", "-n",
				"-f", config,
				"-p", pid,
				"-r", pid)

			env := os.Environ()
			if vrf != "" {
				env = append(env, fmt.Sprintf("VRF=%s", vrf))
				env = append(env, "LD_PRELOAD=/usr/bin/vrf_socket.so")
			}
			fmt.Println("cmd:", cmd)
			cmd.Env = env
			startErr := cmd.Start()
			fmt.Println("cmd.Start()", startErr)
			err := cmd.Wait()
			fmt.Println("cmd.Wait():", err)

			retryTimer := time.NewTimer(time.Second * 1)
			select {
			case <-retryTimer.C:
				fmt.Println("VRRP: retryTimer expired")
			case <-done:
				retryTimer.Stop()
				fmt.Println("VRRP: retryTimer stop")
				return
			}
		}
	}()

	return func() {
		close(done)
		cancel()
		fmt.Println("VRRP: WaitGroup wait")
		wg.Wait()
		fmt.Println("VRRP: WaitGroup done")
		exec.Command("killall", "-s", "TERM", "keepalived").Run()
	}
}

const vrrpConfigTemplateText = `# Do not edit!
# This file is automatically generated from OpenConfigd.
#
vrrp_script bgp_track {
    script /usr/bin/keepalived_track.sh
    interval 1
    fall 3
    rise 3
    weight 50
}

vrrp_instance vrrp{{.Vrid}}-{{.Interface}} {
    notify /usr/bin/keepalived_{{.State}}_{{.Vrf}}.sh
    state {{if eq .State "master"}}MASTER{{else}}BACKUP{{end}}
    interface {{.Vrf}}
    virtual_router_id {{.Vrid}}
    priority {{.Priority}}
    advert_int {{if eq .AdvertisementInterval 0}}10{{else}}{{.AdvertisementInterval}}{{end}}
    use_vmac
    vmac_xmit_base
{{if not .Preempt}}    nopreempt{{end}}
    unicast_peer {
{{range $j, $w := .UnicastPeerList}}        {{$w.Address}}
{{end}}
    }
    virtual_ipaddress {
        {{.VirtualAddress}} dev {{.Interface}}
    }
    track_script {
        bgp_track
    }
    track_interface {
        {{.Interface}}
    }
}
`

func VrrpServerExec(vrrp *Vrrp, vrf string) func() {
	configFileName := fmt.Sprintf("/etc/keepalived/keepalived-%s.conf", vrrp.Interface)
	pidFileName := fmt.Sprintf("/var/run/keepalived-%s.pid", vrrp.Interface)
	srcFileName := fmt.Sprintf("/usr/bin/keepalived_%s.sh", vrrp.State)
	dstFileName := fmt.Sprintf("/usr/bin/keepalived_%s_%s.sh", vrrp.State, vrf)
	os.Remove(dstFileName)
	os.Symlink(srcFileName, dstFileName)

	fmt.Println(configFileName, pidFileName)

	f, err := os.Create(configFileName)
	if err != nil {
		log.Println("Create file:", err)
		return nil
	}
	tmpl := template.Must(template.New("vrrpTemplate").Parse(vrrpConfigTemplateText))

	vrrp.Vrf = vrf
	tmpl.Execute(f, vrrp)

	return VrrpServerStart(configFileName, pidFileName, vrf)
}

func VrrpServerStopAll() {
	for _, vrfInstances := range VrrpInstanceMap {
		for _, instance := range vrfInstances {
			if instance.ExitFunc != nil {
				instance.ExitFunc()
				instance.ExitFunc = nil
			}
		}
	}
	VrrpInstanceMap = map[string][]*VrrpInstance{}
}

func VrrpInstanceGet(vrf string, vrId uint8) *VrrpInstance {
	instance := &VrrpInstance{
		VrId: vrId,
	}
	VrrpInstanceMap[vrf] = append(VrrpInstanceMap[vrf], instance)
	return instance
}

// Called from Commit()
func VrrpJsonConfig(path []string, str string) error {
	var jsonIntf interface{}
	err := json.Unmarshal([]byte(str), &jsonIntf)
	if err != nil {
		fmt.Println("json.Unmarshal", err)
		return err
	}
	vrrpConfig := VrrpConfig{}
	err = mapstructure.Decode(jsonIntf, &vrrpConfig)
	if err != nil {
		fmt.Println("mapstructure.Decode", err)
		return err
	}

	fmt.Println("VrrpJsonConfig", path, vrrpConfig)

	if len(vrrpConfig) == 0 {
		fmt.Println("VrrpJsonConfig: empty VRRP config")
		return nil
	}
	for _, vrrp := range vrrpConfig {
		fmt.Println("VrrpJsonConfig: config", vrrp)

		if len(path) < 3 {
			fmt.Println("VrrpJsonConfig: path length is small", len(path))
			return nil
		}
		vrf := path[2]
		fmt.Println("VrrpJsonConfig vrf:", vrf)

		instance := &VrrpInstance{
			VrId: vrrp.Vrid,
		}
		VrrpInstanceMap[vrf] = append(VrrpInstanceMap[vrf], instance)
		instance.ExitFunc = VrrpServerExec(&vrrp, vrf)
	}

	return nil
}

// Called from etcd.
func VrrpVrfSync(vrfId int, cfg *VrfsConfig) {
	fmt.Println("---- VRRP:", cfg.Vrrp)

	// VrrpServerStopAll()

	vrf := fmt.Sprintf("vrf%d", vrfId)

	vrfInstances := VrrpInstanceMap[vrf]
	for _, instance := range vrfInstances {
		if instance != nil {
			fmt.Println("Vrrp: Existing instance is found clearing", instance)
			if instance.ExitFunc != nil {
				instance.ExitFunc()
				instance.ExitFunc = nil
			}
			ExecLine(fmt.Sprintf("delete vrf name vrf%d vrrp %d", vrfId, instance.VrId))
		}
	}

	if len(cfg.Vrrp) == 0 {
		fmt.Println("No VRRP config")
		return
	}
	for _, vrrp := range cfg.Vrrp {
		ExecLine(fmt.Sprintf("delete vrf name vrf%d vrrp %d", vrfId, vrrp.Vrid))
		ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d", vrfId, vrrp.Vrid))

		if vrrp.Interface != "" {
			ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d interface %s", vrfId, vrrp.Vrid, vrrp.Interface))
		}
		if vrrp.AdvertisementInterval != 0 {
			ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d advertisement-interval %d", vrfId, vrrp.Vrid, vrrp.AdvertisementInterval))
		}
		if vrrp.Preempt {
			ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d preempt", vrfId, vrrp.Vrid))
		}
		if vrrp.Priority != 0 {
			ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d priority %d", vrfId, vrrp.Vrid, vrrp.Priority))
		}
		if vrrp.State == "master" {
			ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d state master", vrfId, vrrp.Vrid))
		} else {
			ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d state backup", vrfId, vrrp.Vrid))
		}
		if vrrp.VirtualAddress != "" {
			ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d virtual-address %s", vrfId, vrrp.Vrid, vrrp.VirtualAddress))
		}
		for _, peer := range vrrp.UnicastPeerList {
			ExecLine(fmt.Sprintf("set vrf name vrf%d vrrp %d unicast-peer %s", vrfId, vrrp.Vrid, peer.Address))
		}
	}
	Commit()
}

func VrrpVrfDelete(vrfId int) {
	fmt.Println("VrrpVrfDelete:", vrfId)

	vrf := fmt.Sprintf("vrf%d", vrfId)

	vrfInstances := VrrpInstanceMap[vrf]
	for _, instance := range vrfInstances {
		if instance != nil {
			fmt.Println("Vrrp: Existing instance is found removing", instance)
			if instance.ExitFunc != nil {
				instance.ExitFunc()
				instance.ExitFunc = nil
			}
			fmt.Println(fmt.Sprintf("delete vrf name vrf%d vrrp %d", vrfId, instance.VrId))
			ExecLine(fmt.Sprintf("delete vrf name vrf%d vrrp %d", vrfId, instance.VrId))
			Commit()
		}
	}
}
